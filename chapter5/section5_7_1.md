5.7.1 矩阵相乘

操作符 `%*%` 用于矩阵相乘。*n×1*或者*1×n*矩阵在情况允许的时候可以作为一 个长度为*n*的向量处理。反之，向量若出现在矩阵相乘的表达式中会被自动转换成与矩阵对应的行或者列向量(有时候比较含糊，后面会有所论述)。

如果 `A` 和 `B` 是大小一样的方阵，那么

```R
> A * B
```

将是一个对应元素乘积的矩阵，而

```R
> A %*% B
```

则是一个矩阵积。如果 `x` 是一个向量，那么

```R
> x %*% A %*% x
```

是一个二次型(quadratic form)[^1]。

函数 `crossprod()` 可以完成“矢积”(crossproduct)运算，也就是说 `crossprod(X, y)` 和 `t(X) %*% y` 等价，但是在运算上更为高效。如果忽略 `crossprod()` 的第二个参数，它将默认和第一个参数一样，即第一个参数和自己进行运算。

函数 `diag()` 的含义依赖于它的参数。当 `v` 是一个向量时，`diag(v)` 返回以该向量元素为对角元素的对角矩阵。当 `M` 是一个矩阵时，`diag(M)` 返回 `M` 的对角元素。 这和 Matlab 中 diag() 的用法完全一致。不过有点容易混淆的是，如果 `k` 是单个值[^2]，那 么 `diag(k)` 的结果就是 k×k 的方阵!





---

[^1]:注意 `x %*% x` 不很明确，因为它既可表示 x′x 又可表示 xx′，其中 x 是列形式。在这种情况下，小矩阵好像比较符合上面的解释，因此标量 x′x 是结果(译者注：这里我也有点困惑，只是字面上翻译了)。矩阵 xx′ 可以通过 `cbind(x) %% x` 或者 `x %*% rbind(x) ` 计算因为 `rbind()` 或者 `cbind()` 的结果都是矩阵。但是，计算 x′x 和 xx′ 最好的办法是`crossprod(x)` 或者 `x %o% x`。
[^2]:译者注：正整数和小数都可以，对于正实数会自动去掉小数部分.